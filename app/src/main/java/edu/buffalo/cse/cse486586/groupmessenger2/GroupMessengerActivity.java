package edu.buffalo.cse.cse486586.groupmessenger2;

import android.app.Activity;
import android.content.ContentValues;
import android.content.Context;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.telephony.TelephonyManager;
import android.text.method.ScrollingMovementMethod;
import android.util.Log;
import android.view.Menu;
import android.view.View;
import android.widget.EditText;
import android.widget.TextView;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;


/**
 * For implementing Total ordering, we fix on distributed algorithm to decide sequence numbers (ISIS)
 * For implementing FIFO Ordering, we sort the data in the delivery queue, based on the Timestamp present in each of the message
 * For example, if the delivery queue for P3 holds messages P2:1 , P1:3 , P1:2, P4:1, P1:1 , a simple way to restrict FIFO ordering is to check the head of the queue
 * to be delivered, and relate its timestamp with the lowest timestamp seen so far for "P1". If the message with lowest timestamp is NOT at head of the
 * queue, then swap their indices, deliver the message, search for the new "lowest timestamp for P1", and save the message details to be compared against during
 * next message delivery.
 * Since the timestamps are generated by the sending process, all the receiving process need not worry about clock drift / skew problems.
 */
/**
 * The message class will be sent in JSON format
 * {
 *     message :"message"
 *     msgType :"msgType"
 *     seqNum  :"seqNum"
 *     procNum :"processNumber"
 *
 * }
 */
/**
 * GroupMessengerActivity is the main Activity for the assignment.
 * 
 * @author stevko
 *
 */
public class GroupMessengerActivity extends Activity {
    static final int SERVER_PORT = 10000;
    //static final String TAG      = GroupMessengerActivity.class.getName();
    static final String TAG      = "TAG";
    static final String[] REMOTE_PORT = {"11108","11112","11116","11120","11124"};
    static public String myPort  = "";
    //private BufferedReader in    = null;
    private PrintWriter out      = null;
    private Socket clientSocket  = null;

    static public EditText editText = null;
    static public TextView textView = null;
    public static SQLHelperClass sql= null;
    /** Helper data structures for FIFO ordering**/
    //private String deliverMessages;
    private Date appStartTime;
    private static Map<String,Integer> processPortMap;

    private int dbSeqNumber      = 0; // message # inserted in DB
    private int[] deliverSeqNumber; //keeps track of maximum sequence number received,

    private HashMap<Message, Integer> msgMapWithMaxSeqNumber;
    //private int[] sentSeqNumber_ ;   //sent sequence number along with every message
    //sentSeqNumber[i] --> denotes the latest seq # sent OUT to process i by this process
    //private LinkedList<String>[] queue;
    //private LinkedList<Message> hold_back_queue;
    private SortedSet<Message> hold_back_queue;
    private LinkedList<Message> delivery_queue;

    private Object lock; // used to synchronize between message receive & actual delivery
    private Map<Message,Integer> countReplyRecv ;// track how many processes sent sequence number
    private int sentSeqNumber;
    private int agreedSeqNumber;
    /** TODO : Remove the timer , this is for test purposes only**/
    //private Timer timer;
    private Handler handler;

    private Map<String,Boolean> aliveProcess; // keeps track of alive processess

    class SortBySeqNumber implements Comparator<Message> {
        @Override
        public int compare(Message m1, Message m2) {
            if (m1.seqNumber > m2.seqNumber) {
                return 1;
            } else if (m1.seqNumber < m2.seqNumber) {
                return -1;
            }
            return 0;
        }
    }
    /**
     * creates map of <port,originPNum> to be used in sending multicast messages
     */
    private static void createPortProcessMap() {
        processPortMap = new HashMap<String, Integer>();
        int counter = 0;
        for(String port:REMOTE_PORT) {
            processPortMap.put(port,counter);
            counter++;
        }
        for(Map.Entry<String,Integer> entry : processPortMap.entrySet()) {
            Log.e(TAG,entry.getKey() + " =>" + entry.getValue());
        }
        Log.e(TAG,"processPortMap size :" + processPortMap.size());
    }

    /**
     *
     */
    private void createServerSocket() {
        try {
            ServerSocket serverSocket = new ServerSocket(SERVER_PORT);
            new ServerTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, serverSocket);
        } catch (IOException e) {
            Log.e(TAG, "Can't create a ServerSocket " + e.getMessage());
            return;
        }

    }
    /* This is step 2.2 of ISIS algorithm. Once the proposed sequence number has been sent to the originator, we store the received message
     * with the "proposed" sequence number in the hold_back queue. The queue is arranged with smallest sequence number in the front
     *
     * */
    private boolean insertIntoHoldBackQueue(Message message) {
        boolean bRes = false;
        if (hold_back_queue.isEmpty()) {
            hold_back_queue.add(message);
            return true;
        }
        Message prev;
        bRes = hold_back_queue.add(message);
        return bRes;
    }
    /**
     * Looks for the proper place to insert the message
     * Proper place is decided by the recvSeqNum parameter
     * The receving buffer is maintained in ascending order of recvSeqNum
     * @param recvSeqNum
     * @param message
     * @return True if the message was inserted in between the two ends of the queue
     *         False if the message was inserted in the end
     * If true is returned, then it means
     */
    private void insertIntoReceiveBuffer(int pNum,int recvSeqNum,String message) {
       /* int prev = Integer.MIN_VALUE;
        for(int i =1 ; i < queue[pNum].size(); i++) {
            prev = Integer.valueOf( queue[pNum].get(i-1).substring(0,queue[pNum].indexOf(':')));
            if (recvSeqNum < prev) {
                queue[pNum].add(i-1,  message);
                /*if (prev - recvSeqNum == 1) { //potentially completes a sequence
                    if (i -1 == 0) { //definitely completes a sequence

                    }
                }
            }

        }
        queue[pNum].add(recvSeqNum + ":" + message);
        return false;*/
    }
    /**
     *
     * @param procNum
     * @param recvSeqNum
     * @return
     */
    private boolean checkIntoDataQueue(String procNum, int recvSeqNum, String message)  {
        int pNum = Integer.valueOf(procNum.charAt(1));
        if (recvSeqNum == deliverSeqNumber[pNum] + 1) // takes care of both the scenarios of recvSeqNum = 0, and recvSeqNum > 0
        {
            deliverSeqNumber[pNum] = recvSeqNum;
            return true;
        } else {
            insertIntoReceiveBuffer(pNum,recvSeqNum,message);
        }
        return false;
    }

    /**
     *
     * @param message
     */
    private void deliverMessage(String message) {
        Log.e(TAG,"message is :" + message);
        int posn = message.indexOf('_');

        String procNum = message.substring(0, posn);
            Log.e(TAG,"deliverMessage procNum " + procNum);
        message  = message.substring(posn + 1);
        int recvSeqNum = Integer.valueOf(message.substring(0, message.indexOf('=')));
            Log.e(TAG,"deliverMessage recvSeqNum " + recvSeqNum);
        message  = message.substring(posn + 1);
            Log.e(TAG," deliverMessage message :" + message);

        boolean bRes = checkIntoDataQueue(procNum, recvSeqNum, message);
        if (bRes) {
            if (deliverSeqNumber[Integer.valueOf(procNum)] == recvSeqNum) { // this message can be delivered
                /*
                * Check if previously buffered messages can be delivered as well
                */

                /*if (!queue[Integer.valueOf(procNum)].isEmpty()) {

                }
                else*/
                {

                    //deliverMessages = message;
                }

            }
        }
        lock.notify();
    }
    /**
     *
     */
    private void createDataQueues() {
        hold_back_queue         = new TreeSet<Message>(new SortBySeqNumber());
        msgMapWithMaxSeqNumber  = new HashMap<Message, Integer>();
        delivery_queue          = new LinkedList<Message>();
        /*queue = new LinkedList[REMOTE_PORT.length];
        for(int i=0; i < REMOTE_PORT.length; i++) {
            queue[i] = new LinkedList<String>();
        }*/
    }
    private void createClientTask() {
        String msgTemp = "Test_" + myPort;
        new ClientTask().executeOnExecutor(AsyncTask.SERIAL_EXECUTOR, msgTemp, myPort);
    }
    /**
     *
     */
    private void createSendButtonEvent() {
        findViewById(R.id.btnSend).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String msg = editText.getText().toString() + "\n";
                Log.e(TAG, "within send button msg :" + msg);
                editText.setText(""); //reset text
                //textView.append("\n" + msg); //append local message
                new ClientTask().executeOnExecutor(AsyncTask.SERIAL_EXECUTOR, msg, myPort);
            }
        });

    }
    private String getMyPort() {
        String myPort;
        TelephonyManager tel = (TelephonyManager) this.getSystemService(Context.TELEPHONY_SERVICE);

        String portStr = tel.getLine1Number().substring(tel.getLine1Number().length() - 4);
        myPort = String.valueOf((Integer.parseInt(portStr) * 2));
        return myPort;
    }
    private  void initAliveProcessSequence() {
        for(String remotePort : REMOTE_PORT) {
            aliveProcess.put(remotePort,true);
        }
    }
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_group_messenger);

        sql = SQLHelperClass.getInstance(getApplicationContext());
        //TODO: Add the code for telephony here
        myPort = getMyPort();

        Log.e(TAG, "Local port found " + myPort);
        appStartTime = new Date();

        createServerSocket();
        createDataQueues();
        createPortProcessMap();


       // deliverSeqNumber = new int[REMOTE_PORT.length];
       // lock = new Object();
        deliverSeqNumber = new int[]{-1,-1,-1,-1,-1};
        aliveProcess     = new HashMap<String, Boolean>();
        initAliveProcessSequence();
        countReplyRecv   = new HashMap<Message, Integer>();
        sentSeqNumber    = 0;
        agreedSeqNumber  = 0;

        TextView tv = (TextView) findViewById(R.id.textViewSend);
        tv.setMovementMethod(new ScrollingMovementMethod());
        
        /*
         * Registers OnPTestClickListener for "button1" in the layout, which is the "PTest" button.
         * OnPTestClickListener demonstrates how to access a ContentProvider.
         */
        findViewById(R.id.button1).setOnClickListener(
                new OnPTestClickListener(tv, getContentResolver()));

        editText = (EditText) findViewById(R.id.editText1);
        textView = (TextView) findViewById(R.id.textViewSend);

        createSendButtonEvent();
    }

    /**
     * if the message's sequence number != hold_back_queue sequence number, re-arrange the hold-back queue
     */
    private void reorderHoldBackQueueIfRequired(Message message) {
        for (Iterator<Message> it = hold_back_queue.iterator(); it.hasNext(); ) {
            Message f = it.next();
            if (f.equals(message)) {
                if (f.seqNumber != message.seqNumber)
                    f.seqNumber = message.seqNumber;
            }
        }
    }
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.activity_group_messenger, menu);
        return true;
    }

    /**
     *
     * @return
     */
    /*private boolean replyWithProposedSequence(Socket clientSocket,Message message) {
        boolean bRes = false;
        ObjectOutputStream outputStream = null;
        try {

            Log.e("reply... :", clientSocket.getRemoteSocketAddress().toString() + " isOutputShut :"
                    + clientSocket.isOutputShutdown() + " ipShut: " + clientSocket.isInputShutdown() + " isConn :" + clientSocket.isConnected()
                    + " isClosed :" + clientSocket.isClosed());
            outputStream = new ObjectOutputStream(clientSocket.getOutputStream());
            outputStream.writeObject(message);
            outputStream.flush();
            //outputStream.
            //outputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return bRes;
    }*/
    private class ReplyClientTask extends AsyncTask<Message, Void, Void>{
        @Override
        protected Void doInBackground(Message... messages) {
            Message message = messages[0];
            ObjectOutputStream outputStream;
            Set<String> aliveProcessPorts = new HashSet<String>(aliveProcess.keySet());
            Log.e("ReplyClientTask exec",message.toString());

            try {

                synchronized (this) {
                    message.isMulticast = false;
                    sentSeqNumber = (sentSeqNumber > agreedSeqNumber) ? sentSeqNumber : agreedSeqNumber;
                    sentSeqNumber++;
                    message.seqNumber = sentSeqNumber;
                    message.remotePort = myPort;
                }
                Log.e(TAG,"message sequenceNumber  " + message.seqNumber);
                InetAddress addr = InetAddress.getByAddress(new byte[]{10, 0, 2, 2});
                SocketAddress socketAddress = new InetSocketAddress(addr, Integer.parseInt(message.originPort)); // now reply to origin port
                Socket socket = new Socket();

                socket.connect(socketAddress, 500); //timeout 500 milliseconds

                try {
                    outputStream = new ObjectOutputStream(socket.getOutputStream());
                    outputStream.writeObject(message);
                    outputStream.flush();
                    outputStream.close();
                } catch (IOException e) {
                    Log.e(TAG, "Exception in ReplyClientTask :" + e.getMessage());
                }
                socket.close();
                Log.e("ReplyClientTask done:",message.toString());

            } catch(SocketTimeoutException ex) {
                Log.e(TAG, "SocketTimeoutException in ReplyClientTask for origin :" + message.originPort
                        + " dest :" + message.remotePort + " destPNum :" + message.destPNum + " reason " + ex.getMessage());
            } catch(UnknownHostException ex) {
                Log.e(TAG, "UnknownHostException in ReplyClientTask for origin :" + message.originPort
                        + " dest :" + message.remotePort + " destPNum :" + message.destPNum + " reason " + ex.getMessage());

            } catch (IOException ex) {
                Log.e(TAG, "IOException in ReplyClientTask for origin :" + message.originPort
                        + " dest :" + message.remotePort + " destPNum :" + message.destPNum + " reason " + ex.getMessage());
            } catch (Exception ex) {
                Log.e(TAG, "Exception in ReplyClientTask for origin :" + message.originPort
                        + " dest :" + message.remotePort + " destPNum :" + message.destPNum + " reason " + ex.getMessage());
            }

            return null;
        }
    }
    private boolean replyWithProposedSequence(Message message) {
        boolean bResult = false;
        Log.e("replyWithPropSeq 1.0","starts");
        if (message != null) {

            if (message.isMulticast && !message.isDeliverable) {
                Log.e("replyWithPropSeq start",message.toString() );
                new ReplyClientTask().execute(message);
                Log.e("replyWithPropSeq end", message.toString());
            }

        } else {
            Log.e("replyWithPropSeq 1.1","null");
        }
        return true;
    }
    private class ServerTask extends AsyncTask<ServerSocket, String, Void> {
        @Override
        protected Void doInBackground(ServerSocket... sockets) {
            Log.e(TAG,"Within background server function");
            /* TODO: Fill in your server code that receives messages and passes them
             * to onProgressUpdate().
             * Referred from : Last assignment
             */
            ServerSocket serverSocket = sockets[0];
            String readLine = "";
            boolean bTrue   = true;
            ObjectInputStream inputStream = null;
            Log.e(TAG,"server socket 1.2");
            try {
                boolean bCanAccept = true;
                while(bCanAccept) {
                    Log.e(TAG,"server socket 1.3");
                    clientSocket = serverSocket.accept();
                    Log.e(TAG, "client socket accepted");
                    try {
                        //synchronized (this)
                        {
                            inputStream = new ObjectInputStream(clientSocket.getInputStream());
                            Message message = (Message) inputStream.readObject();
                            //in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                            //readLine = in.readLine();
                            Log.e(TAG,"message received ");
                            Log.e(TAG, message.toString());
                            clientSocket.close();
                            if (message != null) {
                                /** We have now received proposed sequence number, lets reply to it with our agreed upon sequence number !**/
                                if (message.isMulticast && !message.isDeliverable) { //this is step 2 of ISIS algorithm,

                                    Log.e(TAG,"message is Multicast " + message.toString());
/*
                                    message.isMulticast = false;
                                    sentSeqNumber = (sentSeqNumber > agreedSeqNumber) ? sentSeqNumber : agreedSeqNumber;
                                    sentSeqNumber++;
                                    message.seqNumber = sentSeqNumber;
                                    message.remotePort = myPort;
*/
                                    //Log.e(TAG,"message sequenceNumber  " + message.seqNumber);
                                    if (replyWithProposedSequence(message)) {
                                        Log.e(TAG,"Message " + message.toString() + " sent !" );
                                        insertIntoHoldBackQueue(message);
                                    } else {
                                        /** App failure !! Handle somehow**/
                                        //aliveProcess[processPortMap.get(message.originPort)] = false;
                                        Log.e(TAG,"Message" + message.toString()  +  "  not sent to port " + message.originPort);
                                        if (aliveProcess.containsKey(message.originPort))
                                            aliveProcess.remove(message.originPort);
                                    }

                                } else if (!message.isMulticast && !message.isDeliverable) {
                                    /** Here the step 3 of ISIS algorithm executes,we check for all the receiving messages keeping track of **/
                                    Log.e(TAG, "Message " + message.toString() + " NOT Multicast");
                                    if (checkMaximumReceivedSequenceNumber(message)) {
                                        Log.e("check..SeqNumber ->","true ; size :" + countReplyRecv.get(message));

                                    }  else {
                                        Log.e("check..SeqNumber ->","false");
                                    }
                                    Log.e("check..SeqNumber ->","Number of alive Processes are :" + aliveProcess.size());
                                    if (countReplyRecv.get(message) == aliveProcess.size()) { //maximum count reached
                                        Log.e(TAG,"count limit reached for message " + message.toString());
                                        agreedSeqNumber = msgMapWithMaxSeqNumber.get(message);
                                        sentSeqNumber   = agreedSeqNumber;
                                        message.isDeliverable = true; //message is ready, receivers can send it to their delivery queues if conditions match with hold back queues
                                        message.setTimeStamp((new Date()).getTime() - appStartTime.getTime()); // set the message's timestamp at originator side
                                        sendMessageBroadcast(message); // broadcast to group
                                        countReplyRecv.put(message,0);
                                    } else {
                                        Log.e("Reply wait...",String.valueOf(countReplyRecv.get(message)));
                                    }
                                } else if (!message.isMulticast && message.isDeliverable) {
                                    Log.e(TAG,"Message " + message.toString()  +" is now deliverable ");
                                    printHoldBackQueue();
                                    Log.e("*******BEFORE********", "Before ...");
                                    reorderHoldBackQueueIfRequired(message);
                                    printHoldBackQueue();
                                    Log.e("*******AFTER********","After...");
                                    if (checkIntoHoldBackQueue(message)) {
                                        Log.e(TAG,"Message " + message.toString() + " matches with hold back queue");
                                        insertIntoDeliveryQueue(message);
                                        publishProgress(message.message);
                                        updateDB(message);
                                        // message delivered, free its associated memory
                                        countReplyRecv.remove(message);
                                        msgMapWithMaxSeqNumber.remove(message);
                                        break;
                                        //serverSocket.close();
                                    }
                                }
                                /*publishProgress(message.msg);
                                updateDB(message.msg);*/
                            }
                        }
                        //clientSocket.close();
                    } catch (Exception ex) {
                        Log.e(TAG, "exception in processing client messages " + ex.getMessage());
                        ex.printStackTrace();
                        bCanAccept = false;
                    }
                }
                serverSocket.close();
            } catch (IOException e) {
                Log.e(TAG,"Exception occured in accepting client connections " + e.getMessage());
            }

            return null;
        }
        protected void updateDB(Message message) {
            synchronized (this) {
                ContentValues cv = new ContentValues();
                cv.put("key", dbSeqNumber++);
                cv.put("value",message.message);
                //cv.put(message,++dbSeqNumber);
                Log.e(TAG,"to insert into db :" + message + " seq# " + dbSeqNumber);
                sql.insertValues(cv);
            }
        }
        protected void onProgressUpdate(String...strings) {
            /*
             * The following code displays what is received in doInBackground().
             */

            String strReceived = strings[0].trim();
            GroupMessengerActivity.textView.append(strReceived + "\n");
            GroupMessengerActivity.textView.append("\n");
        }
        private void printHoldBackQueue() {
            int counter = 0;
            Log.e(TAG,"***********Hold back queue starts***********");
            for(Message message : hold_back_queue) {

                Log.e(TAG,message.toString());
            }
            Log.e(TAG,"***********Hold back queue ends*************");
        }
        /** ***/
        private boolean checkIntoHoldBackQueue(Message message) {
            boolean bRes = false;
            if ( hold_back_queue.first().equals(message)) {
                bRes = true;
                hold_back_queue.remove(message);
            }
            return bRes;
        }
        /**
         * The delivery queue is checked for FIFO ordering for message's process ONLY90
         **/
        private Message insertIntoDeliveryQueue(Message message) {

            delivery_queue.add(message);
            return null;
        }
        /** Keeps track of maximum received sequence number, once reply has been received from all 5 processes, we can set agreedSeqNumber
         *  Also, we can reset the sentSeqNumber
         * **/
        private boolean checkMaximumReceivedSequenceNumber(Message message) {
            boolean bRes = false;
            Log.e("check..SeqNumber ->",message.toString());
            Log.e(TAG,"countReplyRecv.size() :" + countReplyRecv.size());
            for(Map.Entry<Message,Integer> entry : countReplyRecv.entrySet()) {
                Log.e("message & sequence",entry.getKey().toString() + " ***: seq number:" + entry.getValue());
            }

            if (countReplyRecv.size() >= aliveProcess.size()) { //fail-safe condition TODO : Check when this condition may occur
                return bRes;
            }
            Log.e("check..SeqNumber ->","1.1");
            for(Map.Entry<String,Boolean> entry : aliveProcess.entrySet()) {
                Log.e("Process port", entry.getKey() + " alive =" + entry.getValue());
            }
            if (!aliveProcess.containsKey(message.originPort)) { // another fail-safe condition, TODO: Check when this condition may occur
                return bRes;
            }
            Log.e("check..SeqNumber ->","1.2");
            if (!msgMapWithMaxSeqNumber.containsKey(message)) {
                msgMapWithMaxSeqNumber.put(message,message.seqNumber);
                countReplyRecv.put(message,1);
                Log.e("check..SeqNumber ->","1.3");
                bRes = true;

            } else {
                /** '<=' is important here, since in initial state, if only 1 process sends out a message, the
                     sequence number is same for everyone**/
                if(msgMapWithMaxSeqNumber.get(message) <= message.seqNumber ) {
                    msgMapWithMaxSeqNumber.put(message, message.seqNumber);
                }
                Log.e("check..SeqNumber ->", "1.3.1 size :" + countReplyRecv.get(message));
                countReplyRecv.put(message,countReplyRecv.get(message)+1);
                Log.e("check..SeqNumber ->", "1.4");
                bRes = true;

            }
            /** Update hold_back_queue  **/
            return bRes;

        }
        /** Reply back to message's originator with the proposed sequence number**/
        private boolean sendMessageBroadcast(Message message) {
            if (message == null)
                return false;
            boolean bRes = false;
            ObjectOutputStream outputStream = null;
            try {
                InetAddress addr = InetAddress.getByAddress(new byte[]{10, 0, 2, 2});
                SocketAddress socketAddress;
                //originPort contains the message originator's port number
                for (String remotePort : REMOTE_PORT) {

                    socketAddress = new InetSocketAddress(addr, Integer.parseInt(remotePort));

                    Socket socket = new Socket();
                    socket.connect(socketAddress, 500); //timeout 500 milliseconds
                    /** if it does not go to next line, conside originator has been terminated**/
                    outputStream = new ObjectOutputStream(socket.getOutputStream());
                    outputStream.writeObject(message);
                    outputStream.close();
                    socket.close();
                    bRes = true;
                }
            } catch(SocketTimeoutException ex) {
                Log.e(TAG, "SocketTimeoutException for originator " + message.originPort + " error reason " + ex.getMessage());
            } catch (SocketException ex) {
                Log.e(TAG, "SocketException for originator " + message.originPort + " error reason " + ex.getMessage());
            } catch(UnknownHostException ex) {
                /** TODO :Process is dead !! Handle somehow **/
                Log.e(TAG,"UnknownHostException in sendMessageBroadcast for originator " + message.originPort +  "error reason " + ex.getMessage());
            } catch(IOException ex) {
                /** TODO :Process is dead !! Handle somehow **/
                Log.e(TAG,"IOException in sendMessageBroadcast for originator " + message.originPort +  "error reason " + ex.getMessage());
            } catch (Exception ex) {
                Log.e(TAG,"Exception in sendMessageBroadcast for originator " + message.originPort +  "error reason " + ex.getMessage());
            }

            return bRes;
        }

    }
    private class ClientTask extends AsyncTask<String, Void, Void> {

        /*private JSONObject writeJSON(String message, String remotePort, String originPNum, String seqNumber) {
            JSONObject jsonObject = new JSONObject();
            try {
                jsonObject.put("message", message);
                jsonObject.put("remotePort", remotePort);
                jsonObject.put("procNum", originPNum);
                jsonObject.put("seqNum", seqNumber);
            } catch (JSONException ex) {
                Log.e(TAG,"Exception to create JSON Object for " + message + " port " + remotePort + " procNum " + originPNum + " seqNum" + seqNumber);
            }
            return jsonObject;

        }*/
        @Override
        protected Void doInBackground(String... msgs) {
                Message message = null;
                Socket socket   = null;
                ObjectOutputStream outputStream = null;
                int i=0;
                Set<String> remotePortSet = new HashSet<String>(aliveProcess.keySet());
                for(String remotePort :remotePortSet) { // bind to all the listed ports
                    try {
                        InetAddress addr = InetAddress.getByAddress(new byte[]{10,0,2,2});
                        SocketAddress socketAddress = new InetSocketAddress(addr,Integer.parseInt(remotePort));

                        socket = new Socket();
                        socket.connect(socketAddress,500); //timeout 500 milliseconds
                        /*socket.connect(InetAddress.getByAddress(new byte[]{10, 0, 2, 2}),
                                Integer.parseInt(remotePort));
                        socket = new Socket(InetAddress.getByAddress(new byte[]{10, 0, 2, 2}),
                                Integer.parseInt(remotePort));
                        */
                        //sentSeqNumber++;
                        /** In step1 : Message object includes <msg,originPort,<seq-number=0>,deliverable=false,multicast=true,originPNum=i>**/
                        //aliveProcess[i] = true;
                        aliveProcess.put(remotePort, true);
                        Log.e(TAG, "Process number " + i + " is alive.");
                        try {
                            message= new Message (msgs[0],myPort,remotePort,0,false,true,processPortMap.get(myPort),i); // in step 1, no sequence number is required to be sent
                        } catch(Exception ex) {
                            Log.e(TAG,"Exception in 1.1.1 :" + ex.getMessage());
                        }

                        try {
                            outputStream = new ObjectOutputStream(socket.getOutputStream());
                        } catch (IOException e) {
                            Log.e(TAG, "Exception in 1.1.2 :" + e.getMessage());
                        }
                        try {
                            outputStream.writeObject(message);
                        } catch (IOException e) {
                            e.printStackTrace();
                            //Log.e(TAG, "Exception in 1.1.3 :" + e.getMessage());
                        }
                        Log.e(TAG, "Sending message from " + myPort + " to port " + remotePort + " for seq number agreement");
                        //json = writeJSON(msgs[0],remotePort,String.valueOf(i),String.valueOf(sentSeqNumber[i]));
                        //sentSeqNumber[i]++;
                        outputStream.flush();
                        i++;
                        outputStream.close();
                        socket.close();
                    } catch( SocketTimeoutException ex) {
                        i++;
                        if (aliveProcess.containsKey(remotePort)) {
                            Log.e(TAG, "process " + remotePort + " is dead !! ");
                            aliveProcess.remove(remotePort);
                        }
                        Log.e(TAG, "ClientTask SocketTimeoutException " + ex.getMessage());
                    } catch (UnknownHostException ex) {
                        /** App failure possibly !! Handle somehow**/
                        i++;
                        if (aliveProcess.containsKey(remotePort)) {
                            Log.e(TAG,"process " + remotePort + " is dead !! ");
                            aliveProcess.remove(remotePort);
                        }
                        Log.e(TAG, "ClientTask UnknownHostException " + ex.getMessage());
                    } catch (IOException ex) {
                        i++;
                        if (aliveProcess.containsKey(remotePort)) {
                            Log.e(TAG,"process " + remotePort + " is dead !! ");
                            aliveProcess.remove(remotePort);
                        }
                        Log.e(TAG, "ClientTask socket IOException " + ex.getMessage());
                    } catch (Exception ex) {
                        i++;
                        if (aliveProcess.containsKey(remotePort)) {
                            Log.e(TAG,"process " + remotePort + " is dead !! ");
                            aliveProcess.remove(remotePort);
                        }
                        Log.e(TAG, "ClientTask socket Exception " + ex.getMessage());
                    }

                }
//            lock.notifyAll(); // TODO : Remove later
            return null;
        }
    }

    /**
     *
     */

}
